using System;
using System.Threading;
using System.Threading.Tasks;

/* Задача: Запустить 5 методов MethodAsync асинхронно и выяснить порядок выполнения асинхронных операций.
 */

namespace AcynsAwait_ExampleTask
{
    class Program
    {
        /// <summary>
        /// Метод, который будет выполняться в другом потоке.
        /// 
        /// На его месте мог бы быть метод обработки большой базы данных,
        /// обработки веб-запроса к серверу или отрисовки тех или иных деталей
        /// графического интерфейса в ответ на ввод пользователя.
        /// В общем всё то, чему лучше выполняться в другом потоке.
        /// </summary>
        private static void Method()
        {
            Console.WriteLine("Async Method: Я запустился в другом потоке!");
            Thread.Sleep(3000);
        }

        //Рассмотрим, как по-разному можно запустить несколько Method используя async await

        /// <summary>
        /// Первый вариант. Методы на самом деле выполняются синхронно.
        /// </summary>
        /*
         * Единственное назначение ключевого слова async – изменить способ компиляции соответствующего метода,
         * на взаимодействие с окружением оно не оказывает никакого влияния.
         */
        private static async void Variant1()
        {
            Console.WriteLine("Variant1: Захватил управление");
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine($"\n***Начало работы Method {i}");

                /* класс Task представляет выполняемую операцию, а его подкласс Task<T> – операцию, которая в
                *  будущем вернет значение типа T. Можно считать, что Task<T> – это
                *  обещание вернуть значение типа T по завершении длительной операции.
                *  Мало объявить выполняемую операцию, необходимо запустить ее выполнение. 
                *  Для этого вызывается метод Run, который принимает делегат -- операцию. 
                *  Таким образом метод запускается в другом потоке.
                */
                Task task = Task.Run(() => Method());


                /* Выражение await приводит к преобразованию метода таким образом,
                *  что он приостанавливается на время выполнения задачи, передает управление основному потоку,
                *  в место, откуда был вызван данный метод, и возобновляется по завершении задачи.
                *  
                *  Так, данный код запускает таск и сразу же начинает ждать, когда он выполнится.
                *  Следующий таск запустится не раньше, чем закончит свою работу предыдущий.
                *  То есть код работает синхронно.
                */
                Console.WriteLine("Variant1: Отдал управление в Main, жду выполнение задачи");
                await task;
                Console.WriteLine("Variant1: Снова захватил управление");
                Console.WriteLine($"Конец работы Async Method {i}");
            }
            Console.WriteLine("Variant1: Снова отдал управление в Main");
        }

        /// <summary>
        /// Второй вариант. Методы выполняются асинхронно.
        /// Методы с сигнатурой async void можно рассматривать как операцию вида "запустил и забыл", 
        /// когда нам не важно,
        /// </summary>
        private static async void Variant2()
        {
            Console.WriteLine("Variant2: Захватил управление");
            //В этом методе await использован корректно. Мы сначала создаем задачи (Task'и) и запускаем их выполняться асинхронно.

            Task[] tasks = new Task[5];

            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine($"Начало работы Async Method {i}");
                tasks[i] = Task.Run(() => Method());
            }
            //***здесь может происходить все, что угодно***

            /*
            * Эти строки также выполняются синхронно, то есть мы последовательно ждем
            * когда закончатся все асинхронные операции. 
            */
            for (int i = 0; i < 5; i++)
            {
                Console.WriteLine("Variant1: Отдал управление в Main, жду выполнение задачи");
                await tasks[i];
                Console.WriteLine("Variant1: Снова захватил управление");
                Console.WriteLine($"Конец работы Async Method {i}");
            }
            Console.WriteLine("Variant1: Снова отдал управление");
        }


        static void Main(string[] args)
        {
            Console.WriteLine("Main thread: Я запустился!");

            Console.WriteLine("Main thread: Передаю управление в метод Variant1...\n");
            Console.WriteLine("Сообщения от Variant1:");
            Variant1();
            Console.WriteLine("Main thread: Мне вернули управление!...");

            Thread.Sleep(30000);

            Console.WriteLine("Main thread: Передаю управление в метод Variant2...\n");
            Console.WriteLine("Сообщения от Variant2:");
            Variant2();

            /*
             * Методы Variant1() и Variant2() с сигнатурой async void.
             * Их вызов происходит по принципу "запустил и забыл", так как только если у метода тип возвращаемого значения Task,
             * то мы сможем дождаться с помощью await его выполнения (ну и еще потому что async Main -- это сомнительно).
             * Так, Если не добавить Console.ReadLine() после вызова вашего асинхронного метода,
             * то программа продолжит выполняться дальше (ведь очередной await вернул управление из метода в Main),
             * то есть просто завершится :)))
             */
            
            /*
             * На самом деле, если следовать паттернам разработки асинхронных программ, никогда не стоит писать async void.
             * Это связано с обработкой исключений, и про это будет подробнее рассказано позднее.
             */
            Console.WriteLine("Main thread: Мне вернули управление!...");
            Console.ReadLine();

        }
    }
}